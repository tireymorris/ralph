#!/usr/bin/env ruby
# frozen_string_literal: true

require 'json'
require_relative '../lib/ralph/agent'
require_relative '../lib/ralph/cli'

MAX_AUTO_RESUME_ATTEMPTS = 10
PRD_FILE = 'prd.json'

def prd_exists?
  File.exist?(PRD_FILE)
end

def stories_remaining?
  return false unless prd_exists?

  begin
    prd = JSON.parse(File.read(PRD_FILE))
    prd['stories']&.any? { |s| s['passes'] != true }
  rescue StandardError
    false
  end
end

def can_auto_resume?(count)
  stories_remaining? && count < MAX_AUTO_RESUME_ATTEMPTS
end

def print_auto_resume(count, context = nil)
  prefix = context ? "Auto-resuming after #{context}" : 'Auto-resuming'
  puts "\nüîÑ #{prefix} (attempt #{count}/#{MAX_AUTO_RESUME_ATTEMPTS})..."
end

def prepare_resume(delay)
  sleep delay
  ['--resume']
end

def run_with_auto_resume(args)
  auto_resume_count = 0

  loop do
    exit_code = Ralph::CLI.run(args)
    return exit_code if exit_code == Ralph::CLI::EXIT_SUCCESS
    return exit_code if exit_code == Ralph::CLI::EXIT_FAILURE && !stories_remaining?

    break exit_code unless can_auto_resume?(auto_resume_count)

    auto_resume_count += 1
    print_auto_resume(auto_resume_count)
    args = prepare_resume(2)
  rescue Interrupt
    puts "\n\n‚ö†Ô∏è Interrupted by user"
    break 130 unless can_auto_resume?(auto_resume_count)

    auto_resume_count += 1
    print_auto_resume(auto_resume_count, 'interrupt')
    args = prepare_resume(2)
  rescue StandardError => e
    puts "\n‚ùå Error: #{e.message}"
    puts e.backtrace.first(5).map { |line| "  #{line}" }.join("\n") if ENV['DEBUG']
    break 1 unless can_auto_resume?(auto_resume_count)

    auto_resume_count += 1
    print_auto_resume(auto_resume_count, 'error')
    args = prepare_resume(3)
  end
end

if __FILE__ == $PROGRAM_NAME
  exit_code = run_with_auto_resume(ARGV)
  exit(exit_code || 0)
end
